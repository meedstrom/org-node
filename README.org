* org-node

How to describe this package... If you know [[https://github.com/org-roam/org-roam][org-roam]], it's like that.  It shares the on-disk format: "notes" are identified by their org-id and you can nest notes.   It even lets you use some org-roam stuff, notably your capture templates and the rich backlinks buffer, without syncing its SQLite DB!

My [[https://github.com/meedstrom/quickroam][quickroam]] package was the initial inspiration.  Now it has grown into a standalone thing.

** Why

Let me get out the door that the package imposes nothing new.  You don't need to "migrate".

Even org-roam imposed no house rules, aside from org-id, which if you're a certain sort of person, you would be using anyway.  You might have thought of it as "the org-roam format" due to lack of competition, but both org-roam and org-node are really just search engines for *the org-id format!*

In pursuit of being "just org-id", this package has no equivalent setting to =org-roam-directory= -- it just looks up =org-id-locations=.

** Feature matrix

For your pleasure, here's a comparison of three similar notetaking systems: all permitting org-id as first-class citizen and not locking you into an "one-note-per-file" concept.

|                                   | org-roam    | org-node         | [[https://github.com/toshism/org-super-links][org-super-links]]      |
|-----------------------------------+-------------+------------------+----------------------|
| Backlinks                         | yes         | yes              | yes                  |
| org-roam-capture integration      | yes         | yes              | no                   |
| Node search and insert            | yes         | yes              | no (suggests org-ql) |
| Node aliases                      | yes         | yes              | not applicable       |
| Rich backlinks buffer             | yes         | yes (org-roam's) | no                   |
| Reflinks                          | yes         | yes (org-roam's) | no                   |
| Ref search and insert             | yes         | yes (org-roam's) | no                   |
| Extract subtree to new file       | yes         | yes              | no                   |
| Backlinks in same window          | no          | yes              | yes                  |
| Avoid double-counting :BACKLINKS: | no          | yes              | yes                  |
| Read =:CACHED_BACKLINKS:= as data   | no          | yes              | no                   |
| Warn about dead links             | no          | yes              | no                   |
| Node exclusion                    | yes         | limited          | not applicable       |
| Can configure rich completions    | yes         | limited          | not applicable       |
| Support =roam:= links               | yes         | no               | no                   |
| Read :BACKLINKS: as data          | no          | no               | yes                  |
| Some query-able cache             | org-roam-db | org-nodes        | no                   |
| Cache mandatory                   | yes         | no               | no                   |
|-----------------------------------+-------------+------------------+----------------------|
| Time to rebuild the cache         | 2m 48s      | < 1s             | not applicable       |

This isn't a totally fair comparison; org-roam has an advantage in the details, see Appendix II.  With org-node I've made what I would've liked to hack on, so it's more simplistic on many aspects.

** Butler wanted

Once upon a time -- a few days ago --  this package was slow: re-scanning my 2900 nodes took over 1 second.  Sure, that's not bad, but [[https://github.com/meedstrom/quickroam][quickroam]] did its thing in 100 ms.  What went wrong?

Well, I had ripgrep grab the nodes' property drawers whole, and then some Elisp parse each one.

May just be my elisp, but it turns out ~5 times faster if I arrange all property drawers in alphabetic order beforehand, and let ripgrep's capture groups return directly the values of each property I seek.

Finally!  A reason to alphabetize stuff, beyond base librarian impulses!

Enable =org-node-butler-mode=, which alphabetizes all property drawers when you save an Org buffer.

(NB: Without =org-node-butler-mode=, lots of data fields in =org-nodes= are blank, and it takes longer to rebuild the cache, but the find and insert commands still work.)

*** Segue

There's a dream of collecting all the data needed to feed org-roam-db so we could totally replace =org-roam-db-sync= and =org-roam-db-autosync-mode=.

But it's hard for regular expressions to collect all the kinds of data that org-roam collects, such as the outline-path, because resolving it requires asking the org-element parser.

To collect such data without rendering Emacs inoperable for three minutes, we'd need some sort of asynchronous or incremental backfilling solution, which makes most sense as a separate system from the grepping.  That brings us to the next topic.

*** The butler, he's a spy!

I'll warn you now about =org-node-butler-mode=: it adds a property to many of your nodes' property drawers.  The property is =CACHED_BACKLINKS=.  It's his little spy book.

When I first ran across that concept in [[https://github.com/toshism/org-super-links][org-super-links]], I didn't like it.  It seemed like clutter, and possibly easy to break.

But that's not true, it's rock-solid!  It's very clever to cache backlinks directly in the file like this, because:

1. Our =org-id= system allows nested nodes (subtree nodes inside other subtrees), the best thing since sliced bread.  They make resolving backlinks a huge optimization challenge.  Not only do you have to parse the file where the link is, you have to open and parse all the targets to find out which subtree they are in.  A naive implementation will easily run at O(N^{2}) or worse.  

2. As some of you nerds know, you get the best performance out of =rg= by executing it once for a whole directory.  One run, one regexp.  If we've cached the backlinks together with the subtrees, it can just grab them while it grabs everything else, leaving zero work to do.

Maybe you still worry about such backlinks growing stale.  So I made two systems against that: first, if you keep =org-node-butler-mode= active all the time, it's not expected to happen unless something broke your save hooks.  It records the appearance and disappearance of links upon save.  Second, when you feel suspicious, the command =org-node-butler-fix-all= will fix all files (slow).

**** And the other data?

The backlinks were the central challenge, but I refuse to create more properties like =CACHED_OLPATH= and =CACHED_INHERITED_TAGS= and so on.  That's just--nah.  Fortunately, collecting most of these is not O(N^{2}), and I have an idea for how to do it: two-three passes of ripgrep with an interim calculation of outline paths.  Then you could also get all inherited properties, eliminate the need to alphabetize, and give org-roam-db a copy of the data so all its commands Just Work.  TBD if I get inspired and have time.

**** Surprising benefit

Did you ever want to be able to see backlinks inside the Org buffer instead of in a separate window?

Well... Now they're right there.

** Config and setup

Install [[https://github.com/BurntSushi/ripgrep][ripgrep]], then add an init snippet like this (assuming [[https://github.com/radian-software/straight.el][straight.el]]):

#+begin_src elisp
(use-package org-node
  :straight (org-node :type git :host github :repo "meedstrom/org-node")
  :hook (org-mode . org-node-enable))
#+end_src

Commands:

- =org-node-find=
  - Counterpart to =org-roam-node-find=
- =org-node-insert-link=
  - Counterpart to =org-roam-node-insert=
- =org-node-insert-include=
- =org-node-insert-transclusion=
- =org-node-insert-transclusion-as-subtree=
- =org-node-nodeify-entry=
- =org-node-create-subtree=
- =org-node-extract-subtree=
  - Bizarro counterpart to =org-roam-extract-subtree=
- =org-node-rewrite-links-ask=
  - Look for link descriptions that got out of sync with the current node title, then prompt at each link to update it
- =org-node-rename-file-by-title=
  - Auto-rename the file based on the current #+title
- =org-node-butler-mass-fix=
  - Good first thing to do, to add =CACHED_BACKLINKS= everywhere
- =org-node-butler-regret=
  - In case you regret using this package -- remove all =CACHED_BACKLINKS=

For config options, type =M-x customize-group RET org-node RET=.  The defaults are aimed at org-roam users.

*Initial setup*

The basic commands should just work, but not backlinks until you run =M-x org-node-butler-mass-fix=.

If you run into any issues, let me know!  Either here on Github or just [[mailto:meedstrom@runbox.eu][email me]] ðŸ’

# Mention taking ownership of org-id

*Known issues*

- "couldn't open /dev/stderr: too many files open" during =org-node-butler-mass-fix=
  - Appears after about 1000 files for me.  It's not an error, just scary.  Interrupt the command and start again; it picks up where it left off, with no further complaint.
  - Two reasons the command opens all files before beginning its work -- first, it's faster that way.  For each link found, it visits the target, so any given file gets visited many times anyway.  Second, it means you can stop and resume at any time.  Very convenient when a problem comes up.

*** Acquiring an org-roam-buffer

To borrow the power of =M-x org-roam-buffer-toggle=, first eval an advice:

#+begin_src elisp
(advice-add 'org-roam-backlinks-get :override #'org-node--fabricate-roam-backlinks)
#+end_src

Check it out, it works!  See for yourself that it isn't using the DB, by evalling =(delete-file org-roam-db-location)=.

The behavior is slightly clobbered.  I don't know what sorts of advanced things people do with the org-roam-buffer but here, the position and properties of each link are gone.  It behaves as if the :unique parameter is t and :point is equal to that of the node heading.

** Limitations
*** Excluding nodes
The =org-node-filter-fn= works well for ignoring TODO items that happen to have an ID, and ignoring org-drill items and that sort of thing, but beyond that, it has limited utility because unlike org-roam, *child ID nodes of an excluded node are not excluded!*

So let's say you have a big archive file, fulla IDs, and you want to exclude all of it.  Putting a =:ROAM_EXCLUDE: t= atop won't do it.  As it stands, what I'd suggest is unfortunately, look at the file name.

The whole point of org-id was to avoid dependence on filenames, but it's often pragmatic to let up on purism just a bit :-) It works well for me to filter out any file or directory that happens to contain "archive" in the name:

#+begin_src elisp
(setq org-node-filter-fn
      (lambda (node)
        (and (not (plist-get node :exclude))
             (not (plist-get node :todo))
             (not (member "drill" (plist-get node :tags)))
             (not (string-search "archive" (plist-get node :file-path))))))
#+end_src

*** Rich completions

In org-roam you could get a node's outline path (=org-roam-node-olp=), which can be used to enrich the completion candidates.

We can do something similar, though our pseudo-outline path does not include subtrees without IDs... only those with, and it makes cache rebuild 50% slower.  It works well, but I'm marking it experimental because I'm not sure how much further I can generalize the code before I've just reinvented org-ql.

(Actually I have an idea about switching out ripgrep for org-ql, but that's a research project... first need to benchmark...)

#+begin_src elisp
(require 'org-node-experimental)
(advice-add 'org-node-cache--scan :override
            #'org-node-experimental--scan)
(advice-add 'org-node-cache-reset :before
            #'org-node-experimental--clear-extra-hash-tables)
(setq org-node-format-candidate-fn 
      (defun my-format-with-olp (node title)
        (concat
         (cl-loop
          for id in (org-node-experimental--olpath->ids
                     (plist-get node :file-path)
                     (plist-get node :pseudo-olpath))
          concat (concat (plist-get (gethash id org-nodes) :title) " -> "))
         title))
(org-node-cache-reset)
#+end_src

** Appendix 0: Command equivalents :noexport:

Things you may as well just use from org-roam.  No vanilla org-mode equivalent, and I won't reinvent the wheel.

- org-roam-tag-add   
- org-roam-alias-add
- org-roam-ref-add
- org-roam-buffer-toggle

** Appendix I: Rosetta stone

API comparison between org-roam and org-node.

You'll notice that org-node "API" is not much of an API, because I try to expose the plumbing:

| Action                          | org-roam                        | org-node                                                                     |
|---------------------------------+---------------------------------+------------------------------------------------------------------------------|
| Get ID at point                 | =(org-roam-id-at-point)=          | =(org-id-get nil nil nil t)=                                                   |
| Get node at point               | =(org-roam-node-at-point)=        | =(gethash (org-id-get nil nil nil t) org-nodes)=                               |
| Get list of files               | =(org-roam-list-files)=           | =(seq-uniq (hash-table-values org-id-locations))=                              |
| Prompt user to pick a node      | =(org-roam-node-read)=            | =(gethash (completing-read "Node: " org-node-collection) org-node-collection)= |
| Get backlink IDs                |                                 | =(plist-get NODE :backlink-ids)=                                               |
| Get org-roam-backlink objects   | =(org-roam-backlinks-get NODE)=   |                                                                              |
| Get title                       | =(org-roam-node-title NODE)=      | =(plist-get NODE :title)=                                                      |
| Get ID                          | =(org-roam-node-id NODE)=         | =(plist-get NODE :id)=                                                         |
| Get filename                    | =(org-roam-node-file NODE)=       | =(plist-get NODE :file-path)=                                                  |
| Get tags                        | =(org-roam-node-tags NODE)=       | =(plist-get NODE :tags)=, no inherited tags                                    |
| Get subtree TODO state          | =(org-roam-node-todo NODE)=       | =(plist-get NODE :todo)=, only that match global =org-todo-keywords=             |
| Get outline level               | =(org-roam-node-level NODE)=      | =(plist-get NODE :level)=, also the boolean =:is-subtree=                        |
| Get =ROAM_ALIASES=                | =(org-roam-node-aliases NODE)=    | =(plist-get NODE :aliases)=                                                    |
| Get =ROAM_REFS=                   | =(org-roam-node-refs NODE)=       |                                                                              |
| Get =ROAM_EXCLUDE=                |                                 | =(plist-get NODE :exclude)=, doesn't inherit parent excludes!                  |
| Get line number                 |                                 | =(plist-get NODE :line-number)=                                                |
| Get char position               | =(org-roam-node-point NODE)=      | =(org-node--visit-get-pos NODE)=                                               |
| Get :PROPERTIES:                | =(org-roam-node-properties NODE)= | =(org-node--visit-get-properties NODE)=                                        |
| Get title of file where NODE is | =(org-roam-node-file-title NODE)= | =(org-node--visit-get-file-title NODE)=                                        |
| Get subtree heading sans TODO   | =(org-roam-node-title NODE)=      | =(org-node--visit-get-true-heading NODE)=                                      |
| Get outline-path                | =(org-roam-node-olp NODE)=        |                                                                              |
| Get subtree priority            | =(org-roam-node-priority NODE)=   |                                                                              |
| Get subtree SCHEDULED           | =(org-roam-node-scheduled NODE)=  |                                                                              |
| Get subtree DEADLINE            | =(org-roam-node-deadline NODE)=   |                                                                              |
| Get org-roam-reflink objects    | =(org-roam-reflinks-get NODE)=    |                                                                              |
| Ensure fresh data               | =(org-roam-db-sync)=              | =(org-node-cache-ensure-fresh)=                                                |

As you might infer, all the stuff in an org-node plist was collected by Ripgrep, and for the rest, a "visit-get" function like =org-node--visit-get-properties= has to visit the target.  It's a bad idea to call a "visit-get" from your =org-node-filter-fn= or =org-node-format-candidate-fn=, as that horribly slows down the cache rebuilds -- to the speed of an =(org-roam-db-sync 'force)=, in fact.

** Appendix II: Pros of org-roam

1. It is the most general toolkit.  Take a function like =org-roam-id-at-point=.  Why does it exist, when you could use =(org-id-get nil nil nil t)=?  Well, the org-roam version ignores those ancestor headings that have an ID but have been marked not to count as "Roam nodes", so it travels further up the tree until it finds one that is indeed "a Roam node".

   - This brings good to users.  Complexity is not the enemy.  It's just a bit of a YAML vs TOML situation.  Or lsp-mode vs eglot.  I prefer to try to be "closer to the metal", use vanilla =org-capture= instead of =org-roam-capture=, look up vanilla =org-id-locations= instead of =org-roam-directory= etc.  Not have so many wrappers.

2. Take the variable =org-roam-mode-sections=.  Under any ordinary Emacs Lisp package, this would just be a list of functions.  But in fact, you can add to it a cons cell of a function plus the arguments to pass to it.  I like programmability, but this is ... oriented towards people who aren't programmers, I think.

   - It does make the org-roam source code a slower read.  You scratch your head and ask "Why is it made that way?"  Then you see, and you say "Ah, but /I/ don't need that!"  Well, maybe someone does.

3. Take the variable =org-roam-node-display-templates=.  At least, others may consider this a pro, but for my tastes no.  I try to let people customize with little lambdas and provide examples of how they'd get some result or other.  This instead has the dream UI where you can just set the variable to a string ="${olp} -> ${title}"= and be done with it.  Problem is it's a new mini-DSL (domain-specific language), and when you learn it you miss out on an elisp lesson.  Convenient for beginners but also /keeps/ them beginners.

** Appendix III: Other bonus fixes

On Doom's Org module, you may need a fix to use org-transclusion:

#+begin_src elisp
(if (modulep! :lang org)
    ;; fix interference with org-transclusion
    (after! org
      (advice-remove 'org-link-search '+org--recenter-after-follow-link-a)))
#+end_src

* Question for you

I want to try to merge =:ROAM_REFS:= with the =:ID:= field.  I.e. let you paste URLs (or any other text string) directly on the ID field, because that's all =ROAM_REFS= are, and such a design would make it self-evident.  I think there must be many people today who remain unsure what a roam ref is because they put it on the backlog along with 500 other Emacs/Org concepts to learn.

Plus, such a design would mean I can run the same code to collect backlinks as reflinks, as reflinks would just /be/ backlinks.

Maybe if that doesn't pan out, we could make an =ID_ALIASES= field, so it's at least cognate to =ROAM_ALIASES=.

Or =EXTRA_IDS=.

What do you think? Awesome? Terrible?
